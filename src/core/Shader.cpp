#include "Shader.h"
#include <string>

DXCRes ShaderCompiler()
{
    DXCRes dxcRes;

    DX_ASSERT(DxcCreateInstance(CLSID_DxcUtils, IID_PPV_ARGS(dxcRes._pUtils.GetAddressOf())));
    DX_ASSERT(DxcCreateInstance(CLSID_DxcCompiler, IID_PPV_ARGS(dxcRes._pCompiler.GetAddressOf())));
    DX_ASSERT(dxcRes._pUtils->CreateDefaultIncludeHandler(dxcRes._pIncludeHandler.GetAddressOf()));
	return dxcRes;
}

Shader CreateShader(GfxDevice& gfxDevice, DXCRes& dxcRes, const ShaderDesc& shaderDesc)
{
    Shader shader{};

    if (shaderDesc._type == Type::VERTEX)
        shader._type = Type::VERTEX;
    else if (shaderDesc._type == Type::PIXEL)
        shader._type = Type::PIXEL;

    // shader model 6.0 and up code

    wchar_t* path = shaderDesc._shaderPath;
    wchar_t* filename = wcsrchr(path, L'/');
    if (filename != nullptr)
    {
        filename++;
    }
    else
    {
        filename = path;
    }

    std::wstring binName = std::wstring(filename) + L".bin";
    std::wstring pdbName = std::wstring(filename) + L".pdb";

    LPCWSTR pszArgs[] =
    {
        shaderDesc._shaderPath,         // Optional shader source file name for error reporting
										// and for PIX shader source view.  
		L"-E", shaderDesc._pEntryPoint,
		L"-T", shaderDesc._pTarget,  
		L"-Zs",                         // Enable debug information (slim format)
		/*L"-D", L"myTex2DSpace=0",*/   // A single define.
		L"-Fo", binName.c_str()         // Optional. Stored in the pdb. 
		/*L"-Fd", pdbName.c_str()*/,    // The file name of the pdb. This must either be supplied
										// or the autogenerated file name must be used.
		L"-Qstrip_reflect",             // Strip reflection into a separate blob.
    };

    // open source file
    DX_ASSERT(dxcRes._pUtils->LoadFile(shaderDesc._shaderPath, nullptr, shader._pBlobEnc.GetAddressOf()));
    shader._source.Ptr = shader._pBlobEnc->GetBufferPointer();
    shader._source.Size = shader._pBlobEnc->GetBufferSize();
    shader._source.Encoding = DXC_CP_ACP;

    // compile it with the arguments
    DX_ASSERT(dxcRes._pCompiler->Compile(&shader._source,
        pszArgs,
        _countof(pszArgs),
        dxcRes._pIncludeHandler.Get(),
        IID_PPV_ARGS(&shader._result)));
    ComPtr<IDxcBlobUtf16> pShaderName = nullptr;

    HRESULT resultCode;
    shader._result->GetStatus(&resultCode);
    if (FAILED(resultCode))
    {
        ComPtr<IDxcBlobEncoding> pError;
        if (SUCCEEDED(shader._result->GetErrorBuffer(&pError)) && pError)
        {
            OutputDebugStringA("\n--- SHADER COMPILATION ERROR ---\n");
            printl(Log::LogLevel::Error, "Errors: {}", (const char*)pError->GetBufferPointer());
            OutputDebugStringA("\n--------------------------------\n");
            
        }
        DX_ASSERT(false);
    }

    DX_ASSERT(shader._result->GetOutput(DXC_OUT_OBJECT, IID_PPV_ARGS(&shader._pBlob), &pShaderName));
    if (shader._pBlob != nullptr)
    {
        FILE* fp = NULL;

        _wfopen_s(&fp, pShaderName->GetStringPointer(), L"wb");
        fwrite(shader._pBlob->GetBufferPointer(), shader._pBlob->GetBufferSize(), 1, fp);
        fclose(fp);
    }

    ComPtr<IDxcBlob> pPDB = nullptr;
    ComPtr<IDxcBlobUtf16> pPDBName = nullptr;
    shader._result->GetOutput(DXC_OUT_PDB, IID_PPV_ARGS(&pPDB), &pPDBName);
    {
        FILE* fp = NULL;

        // Note that if you don't specify -Fd, a pdb name will be automatically generated.
        // Use this file name to save the pdb so that PIX can find it quickly.
        _wfopen_s(&fp, pPDBName->GetStringPointer(), L"wb");
        fwrite(pPDB->GetBufferPointer(), pPDB->GetBufferSize(), 1, fp);
        fclose(fp);
    }

    // pre dxc code, for shader model < sm_6_0
//#if defined(DEBUG)
//    constexpr u32 compilerFlags = D3DCOMPILE_DEBUG | D3DCOMPILE_SKIP_OPTIMIZATION;
//#else
//    u32 compilerFlags = 0;
//#endif
//
//    D3D_SHADER_MACRO shaderMacros[2];
//    shaderMacros[0].Name = "myTex2DSpace";
//    shaderMacros[0].Definition = "space0";
//
//    shaderMacros[1].Name = nullptr;
//    shaderMacros[1].Definition = nullptr;
//
//    D3D_SHADER_MACRO* ppShaderMacros = {shaderMacros};
//
//    ComPtr<ID3DBlob> pErrorBlob = nullptr; // Create a blob to hold error messages
//
//    HRESULT hr = D3DCompileFromFile(
//        shaderDesc._shaderPath,
//        shaderMacros,         // Just pass the array, it will decay to a pointer
//        D3D_COMPILE_STANDARD_FILE_INCLUDE,
//        shaderDesc._pEntryPoint,
//        shaderDesc._pTarget,
//        compilerFlags,
//        0,
//        &shader._pBlob,
//        &pErrorBlob           // Capture errors here!
//    );
//
//    // If compilation failed, print the error message
//    if (FAILED(hr))
//    {
//        if (pErrorBlob)
//        {
//            // Output the error message to the debug console
//            OutputDebugStringA((char*)pErrorBlob->GetBufferPointer());
//        }
//        // You should probably throw an exception or handle the error here
//        DX_ASSERT(hr);
//    }
    return shader;
}
